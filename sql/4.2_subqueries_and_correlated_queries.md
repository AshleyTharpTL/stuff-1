### HAVING SUBQUERIES
restricts the output of a GROUP BY query by applying conditional criteria to the grouped rows. For example, to list all products with a total quantity sold greater than the average quantity sold, you would write the following query:
```
SELECT P_CODE, SUM(LINE_UNITS)
FROM LINE
GROUP BY P_CODE
HAVING SUM(LINE_UNITS) > (SELECT AVG(LINE_UNITS) FROM LINE);

```

### Multirow Subquery operators: ANY and ALL
IN basically checks for equality in a list, but what about a less than or greater than?

### Attribute List SubQueries
The SELECT statement uses the attribuet list to indicate what columns to project in the resulting set. Those calumns can be attributes of base tables, computed attributes, or the result of an aggregate function. The attribute list can also include a subquery expression, also known as an inline subquery. A subquery in the attribute list must return one value; otherwise, an error code is raised.

You can put a subquery in the FROM clause
```
SELECT P_CODE, SALES, ECOUNT, SALES/ECOUNT AS CONTRIB
FROM (SELECT P_CODE, SUM(LINE_UNITS * LINE_PRICE) AS SALES,
FROM LINE
GROUP BY P_CODE);
```

### CORRELATED SUBQUERIES
Until now all subqueries you have learned execute independently. That is, each subquery in a command sequence executes in a serial fasion, one after another. The inner subquery executes first; its output is used by the other query, which then executes until the last outer query finishes.

A **corellated subquery** executes once for each return in the outer query, similar to a nested loop.

```
SELECT INV_NUMBER, P_CODE, LINE_UNITS
FROM LINE LS
WHERE LS.LINE_UNITS > (SELECT AVG(LINE_UNITS)
		FROM LINE LA
		WHERE LA.P_CODE = LS.P_CODE);
```


